import {
	Client,
	ClientOptions,
	Collection,
	REST,
	Routes,
	ApplicationCommand
} from 'discord.js';
import { handleCommands } from '../functions/handleCommands';
import { handleEvents } from '../functions/handleEvents';
import { deploy } from '../functions/deploy';
import {
	AdditionalClientOptions,
	AutoGeneratedHelpSettings,
	ParsedSlashCommand
} from '../types/interfaces';
import { ParsedCommand, AnyEvent } from '../types/aliases';
import { Logger } from './Logger';
import { CommandError } from './errors/CommandError';
import { DeployError } from './errors/DeployError';

/**
 * The client used for discm.js programs.
 * @extends Client
 */
export class DiscmClient extends Client {
	private _commandsDir: string;
	private _eventsDir: string;

	/**
	 * A {@link Collection} containing all parsed commands.
	 */
	public commands: Collection<string, ParsedCommand>;

	/**
	 * A {@link Collection} containing all events.
	 */
	public events: Collection<string, AnyEvent>;

	/**
	 * Exposes an initiation of the {@link Logger} class.
	 */
	public logger: Logger;

	/**
	 * The prefix the bot uses for text commands.
	 * @default "!"
	 */
	public prefix: string;

	/**
	 * Whether to deploy commands globally or not.
	 * @default true
	 */
	public global: boolean;

	/**
	 * Whether to deploy all commands as soon as the bot logs in or not.
	 * If true, you will have to manually deploy commands after the bot has logged in using {@link DiscmClient.deploy deploy}.
	 * @default false
	 */
	public delayedDeploy: boolean;

	/**
	 * Whether to auto generate a help command for you.
	 * The help command is a slash (/) command that accepts 1 string option.
	 * The string option is a list of other command names that the user wants to learn more about.
	 * An object can be passed to customize how the command works.
	 * If true, the command will use a set of default values.
	 * @default false
	 */
	public autoGenerateHelp: boolean | AutoGeneratedHelpSettings;

	constructor(options: ClientOptions & AdditionalClientOptions) {
		super(options);

		this._commandsDir = options.dirs.commands;
		this._eventsDir = options.dirs.events;
		this.prefix = options.prefix || '!';
		this.global = options.global !== undefined ? options.global : true;
		this.delayedDeploy =
			options.delayDeploy !== undefined ? options.delayDeploy : false;
		this.autoGenerateHelp =
			options.autoGenerateHelpCommand !== undefined
				? options.autoGenerateHelpCommand
				: false;

		this.commands = new Collection();
		this.events = new Collection();

		this.logger = new Logger();

		handleCommands(this, this._commandsDir);
		handleEvents(this, this._eventsDir);
	}

	/**
	 * Logs the bot into discord. Emits the `ready` event once the client successfully logs in.
	 * This method also automatically deploys all slash commands.
	 * If {@link DiscmClient.delayDeploy delayed deploy} is set to true, the commands will not deploy.
	 * @param token The token of the bot account to log in to. Can be obtained via {@link https://discord.com/developers discord developer portal}.
	 * @param guildId The id of a guild (or a list of guild ids) to privately deploy commands to. If the bot is not a global bot, the parameter is not required.
	 * @returns Promise<string>
	 */
	public override async login(token: string, guildId?: string | string[]) {
		if (guildId === undefined && !this.delayedDeploy && !this.global)
			throw new DeployError(
				'Cannot privately deploy with no provided guild ids.'
			);

		await super.login(token);
		if (!this.delayedDeploy) await deploy(this, guildId);

		return token;
	}

	/**
	 * Exposes the {@link deploy} method.
	 * @param guildId The guilds to privately deploy commands to.
	 */
	public async deploy(guildId?: string | string[]) {
		if (guildId === undefined && !this.global)
			throw new DeployError(
				'Cannot privately deploy with no provided guild ids.'
			);
		await deploy(this, guildId);
	}

	/**
	 * Will delete a specific slash command.
	 * @param name The name of the slash command to delete.
	 */
	public async deleteSlashCommand(name: string) {
		if (!this.isReady())
			throw new CommandError(
				'Cannot delete commands before the bot is online.'
			);
		const rest = new REST().setToken(this.token);

		const commands = (await rest.get(
			Routes.applicationCommands(this.user.id)
		)) as ApplicationCommand[];

		for (const command of commands) {
			if (command.name === name) {
				await rest.delete(
					Routes.applicationCommand(this.user.id, command.id)
				);
				break;
			}
		}
	}

	/**
	 * Will deploy a specific slash command.
	 * @param name The name of the command to deploy.
	 * @param guildId The guild id to deploy to if the client is not global.
	 */
	public async deployCommand(name: string, guildId?: string | string[]) {
		if (!this.isReady())
			throw new DeployError(
				'Cannot deploy commands before the bot is online.'
			);
		if (guildId === undefined && !this.global)
			throw new DeployError(
				'Cannot privately deploy with no provided guild ids.'
			);
		if (!this.commands.find((_, n) => name === n))
			throw new CommandError(
				`Cannot find command '${name}'. Make sure commands are parsed before trying to deploy them.`
			);
		const rest = new REST().setToken(this.token);

		const command = this.commands.find(
			(c, n) => name === n && c.type === 'slash'
		)! as ParsedSlashCommand;

		this.logger.custom([`Deploying command ${name}`], 'deploy', 'blue');
		if (this.global) {
			await rest.put(Routes.applicationCommands(this.application.id), {
				body: [command.data]
			});
		} else {
			if (Array.isArray(guildId)) {
				for (const id of guildId) {
					await rest.put(
						Routes.applicationGuildCommands(
							this.application.id,
							id
						),
						{
							body: [command.data]
						}
					);
				}
			} else {
				await rest.put(
					Routes.applicationGuildCommands(
						this.application.id,
						guildId!
					),
					{
						body: [command.data]
					}
				);
			}
		}
	}

	/**
	 * Deletes every deployed slash command.
	 */
	public async clearSlashCommands() {
		if (!this.isReady())
			throw new CommandError(
				'Cannot delete commands before the bot is online.'
			);
		const rest = new REST().setToken(this.token);

		const commands = (await rest.get(
			Routes.applicationCommands(this.user.id)
		)) as ApplicationCommand[];

		for (const command of commands) {
			await rest.delete(
				Routes.applicationCommand(this.user.id, command.id)
			);
		}
	}
}
